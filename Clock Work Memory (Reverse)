Enunciado:
Clock Work Memory Twillie's "Clockwork Memory" pocketwatch is broken. The memory it holds, a precious story about the Starshard, has been distorted. By reverse-engineering the intricate "clockwork" mechanism of the pocketwatch.wasm file, you can discover the source of the distortion and apply the correct "peppermint" key to remember the truth.

Dificultad: easy

Writeup â€” Clock Work Memory
Reversing Â· WebAssembly Â· Hack The Box
Challenge Information

Nombre: Clock Work Memory

CategorÃ­a: Reversing

Plataforma: Hack The Box

Objetivo: Recuperar la flag oculta dentro de un binario WebAssembly

ğŸ§  DescripciÃ³n

Se nos da un archivo pocketwatch.wasm, un binario WebAssembly.
La historia narra un reloj con memoria distorsionada que debe restaurarse con una clave correcta. Esto sugiere que la flag estÃ¡ ofuscada dentro del binario, y que debemos analizar su lÃ³gica interna para recuperarla.

Nuestro objetivo fue entender cÃ³mo reconstruir dicha flag y extraerla sin explotaciÃ³n externa, basÃ¡ndonos Ãºnicamente en anÃ¡lisis estÃ¡tico y dinÃ¡mico del binario.

ğŸ” AnÃ¡lisis del binario

Convertimos el binario WebAssembly a formato .wat con:

wasm2wat pocketwatch.wasm


Esto nos permitiÃ³ inspeccionar la lÃ³gica interna.
Encontramos que la funciÃ³n exportada principal es:

(export "check_flag" (func 1))


âš ï¸ Importante:
Esta funciÃ³n comprueba la flag, pero no la imprime.

La lÃ³gica detectada fue:

Se reserva memoria en el stack para construir la flag.

Se rellena con datos descifrados (XOR).

Se compara con la entrada del usuario.

ğŸ“Œ Esto indica que la flag se construye internamente antes de la comparaciÃ³n.

ğŸ§± Funcionamiento interno

El flujo mÃ¡s relevante es:

Reserva de espacio en stack:

global.get 0
i32.const 32
i32.sub
local.tee 2
global.set 0


Se reservan 32 bytes de stack para construir la cadena.

Descifrado / XOR:

El programa recorre 23 bytes de datos ofuscados, los XORea y los escribe en el buffer.

Terminador nulo:

i32.store8 offset=23


Esto aÃ±ade un terminador \0, indicando el final de la cadena.

ComparaciÃ³n contra la entrada:

El binario compara byte a byte con lo que tÃº ingreses. Si coinciden, retorna 1; si no, 0.

Este diseÃ±o no nos permite usar brute force incremental, ya que el valor 0 solo indica â€œno es correctoâ€, sin revelar informaciÃ³n parcial.

ğŸš« MÃ©todos descartados

El anÃ¡lisis revelÃ³ que enfoques como:

Fuerza bruta carÃ¡cter a carÃ¡cter

Oracle parcial basado en retorno de la funciÃ³n

Brute force con terminador manual

no eran aplicables, porque la funciÃ³n solo devuelve 1 si toda la cadena completa coincide. No hay retorno diferenciado por prefijo correcto o incorrecto.

ğŸ§ª Enfoque correcto: lectura directa de memoria

Sabemos que el binario construye completamente la flag en memoria antes de compararla.
Podemos aprovechar esto leyendo el buffer justo despuÃ©s de que el binario construye la cadena.

El valor inicial del stack global es:

(global (;0;) (mut i32) (i32.const 66592))


Como se reservan 32 bytes, sabemos que la flag estÃ¡ en:

66592 - 32


Leyendo 23 bytes desde esa direcciÃ³n obtenemos la flag completa.

ğŸ Flag
HTB{cl0ck_w0rk_m3m0ry}

ğŸ“Œ Conclusiones

ğŸ¯ Lecciones clave:

No siempre es necesario brute force.

Entender el flujo de ejecuciÃ³n puede dar acceso a datos intermedios.

WebAssembly puede ser analizado efectivamente con wasm2wat.
