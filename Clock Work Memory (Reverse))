Enunciado:
Clock Work Memory Twillie's "Clockwork Memory" pocketwatch is broken. The memory it holds, a precious story about the Starshard, has been distorted. By reverse-engineering the intricate "clockwork" mechanism of the pocketwatch.wasm file, you can discover the source of the distortion and apply the correct "peppermint" key to remember the truth.

Dificultad: easy

En este reto se nos proporciona un binario WebAssembly (pocketwatch.wasm).
La narrativa sugiere que una memoria ha sido â€œdistorsionadaâ€ y que debe aplicarse la clave correcta para restaurarla.

Desde el punto de vista tÃ©cnico, estamos ante un reto de reversing puro, donde la flag no se imprime, sino que se reconstruye dinÃ¡micamente en memoria.

ğŸ” AnÃ¡lisis inicial

El primer paso es inspeccionar el binario:

wasm2wat pocketwatch.wasm

Esto convierte el archivo .wasm a formato texto (.wat) y permite analizar su lÃ³gica interna.

Al revisar el cÃ³digo, destaca la funciÃ³n exportada:

(export "check_flag" (func 1))

âš ï¸ Importante:
No existe ninguna funciÃ³n que imprima la flag.
check_flag solo valida, no revela.

âš™ï¸ Funcionamiento interno de check_flag

Analizando la funciÃ³n paso a paso, observamos lo siguiente:

ğŸ§± Reserva de stack
global.get 0
i32.const 32
i32.sub
local.tee 2
global.set 0

Se reservan 32 bytes en el stack

local 2 apunta al inicio del buffer

ğŸ” Descifrado mediante XOR

Se ejecuta un bucle de 23 iteraciones donde:

Se leen bytes de un bloque data

Se aplica una operaciÃ³n XOR

El resultado se escribe en el buffer del stack

Al finalizar, se aÃ±ade un terminador nulo:

i32.store8 offset=23

Esto deja una cadena C vÃ¡lida en memoria.

âŒ ComparaciÃ³n final

La cadena reconstruida se compara byte a byte con la entrada del usuario.
La funciÃ³n solo devuelve 1 si TODA la cadena coincide

ğŸ§  Enfoque correcto

La clave del reto es entender que:

La flag existe completa en memoria antes de ser comparada

Por tanto, el enfoque correcto no es adivinar la flag, sino leerla directamente desde memoria.

ğŸ§ª ExtracciÃ³n desde memoria

El puntero global del stack estÃ¡ inicializado en:

(global (;0;) (mut i32) (i32.const 66592))

Como se reservan 32 bytes, el buffer comienza en:

66592 - 32

Leyendo 23 bytes desde esa direcciÃ³n se obtiene la flag completa.

âœ… ConclusiÃ³n

Este reto demuestra que en reversing moderno:

âŒ El brute force no siempre es viable

âœ… Entender el flujo de ejecuciÃ³n es clave

âœ… Leer memoria en el momento adecuado resuelve el reto

Un ejercicio excelente para familiarizarse con WebAssembly y gestiÃ³n de stack.
